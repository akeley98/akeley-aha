\documentclass[11pt]{article}
\usepackage[letterpaper, portrait, margin=4cm]{geometry}

\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{placeins}
\usepackage{graphicx}
\usepackage{caption}
\usepackage[parfill]{parskip}
\newcommand{\solution}[1]{{{\color{blue}{\bf Solution:} {#1}}}}
\usepackage[usenames,dvipsnames,svgnames,table,hyperref]{xcolor}


\begin{document}
\title{Contributions to Aetherling}
\author{David Akeley}
\maketitle

\begin{abstract}
This is a list of my contributions to the Aetherling project. I start
with a section summarizing tasks I worked on, then I expand on the
tasks in further sections.
\end{abstract}

\section{Summary}

\begin{enumerate}

\item Line Buffer Specifications

I proposed a new specification of Aetherling's line buffer node and
wrote a document (``The Line Buffer Manifesto'') describing the
benefits of this redesign. The previous line buffer design was hard to
parallelize due to difficult-to-satisfy constraints on its parameters'
divisibility, and also did not support downsampling (``stride'').
The redesign addresses these issues.

% Essential decision - move responsibility of bounds checking out
% of the line buffer; someone else downsteam will figure it out.
% For the purposes of timing, out-of-bounds pixels are considered
% valid outputs. Only later do we deal with the fact that they're
% actually garbage.

\item Functional Simulator

I wrote a functional simulator for Aetherling, which includes a
simulation of the intended behavior of the redesigned line
buffer. This allows the user to test the functionality of an
Aetherling DAG using pure Haskell code.

\item Demonstration Apps

I designed two demonstration Aetherling DAGs: Gaussian blur (7 $\times$
7 stencil) and mipmap generation. These DAGs can be tested using the
functional simulator along with a library (\texttt{ImageIO.hs}) for
converting between simulator values and png images on disk. These apps
also demonstrate the applications of the redesigned line buffer.

\item Simplifying Ops

An op is a node of an Aetherling DAG (along with its children,
sometimes). Previously there were multiple ways to express the same
functionality. I simplified the ops to minimize redundancy.

\item Helper Functions

I wrote some Haskell helper functions for creating ops and simple
patterns of ops. These helpers check for invalid parameters and
substitute for functionality lost through the op simplification.

\item Ready-Valid Meta-Op

By default, Aetherling pipelines are composed of ops representing
circuits with synchronous timing: they wait for a certain number of
warm-up cycles, then emit outputs on a repeating schedule. I designed
a \texttt{ReadyValid} op that represents the idea of wrapping a portion
of an Aetherling DAG with a ready-valid interface.  I modified the
compose operators (\texttt{|\&|} and \texttt{|>>=|}) to properly handle
the `ReadyValid` op.  The user is prevented from composing an op with
ready-valid timing with one with synchronous timing, and, when
composing two ready-valid ops in sequence, the throughput-matching
behavior of the Aetherling type system is suppressed.

\item ComposePar Retiming

Aetherling includes a \texttt{ComposePar} op that represents placing
circuits (child ops) in parallel. The user is not required to ensure
that each parallel path has the same latency (sequential latency --
the count of the number of register delays along a path). I wrote a
pass that walks an Aetherling DAG searching for \texttt{ComposePar}
ops, modifying its child ops if needed such that all paths have the
same latency. The pass finds an optimal solution that minimizes the
number of register bits added to the circuit.

\item Fractional Underutilization and Phase

In the Aetherling team, ``phase'' refers to the repeating pattern of
valid and garbage values input to/generated by a synchronously timed
op. For example, an op that generated 1 valid output every 3 cycles
would have an output phase of \texttt{[True, False, False]} (Two out
of every three cycles, the op generates garbage).

The choice of phase for an op with integer underutilization (1 valid
input/output per $X$ clock cycles) is obvious, but with fractional
underutilization ($X$ valid per $Y$ clocks), there are several
reasonable phase choices. When several such underutilized ops
are joined together, there's no guarantee that their phase patterns
will match.

Since the Aetherling type system only exposes type and throughput
information to the user, it's vital that the system take care of phase
matching automatically. I proposed a scheme that assigns each
fractional utilization ratio a standardized phase. (The earlier phase
corresponds to $\frac{1}{3}$ utilization). This allows the complexity
of phase matching to be confined to one op in the system,
\texttt{SequenceArrayRepack}. Along with the ComposePar retiming pass,
this makes it so that users only have to be concerned with type and
throughput matching, allowing them to view phase and latency as
performance, rather than correctness, issues.

\item Tests Written

I gained a lot of experience writing tests as part of my work
on the Aetherling project. These tests include:

\begin{enumerate}

\item Haskell tests for the functional simulator I designed.

\item Python tests for the hardware line buffer David Durst is
  designing based on ``The Line Buffer Manifesto''
  specifications. These tests use the CoreIR simulator.

\item Tests for the sequential compose (\texttt{|>>=|}) and parallel
  compose (\texttt{|\&|}) Haskell Aetherling operators. These tests
  check that the produced Haskell IR node is correct given valid
  operands, and check that the operators reject invalid operands
  (mismatched port types, mismatched synchronous and ready-valid
  timing, and mismatched throughputs with synchronous timing).

\item Tests for the \texttt{ComposePar} retiming passes. There are
  $18+$ test cases, some of which have compose ops nested several
  layers deep meant to check for corner cases.
\end{enumerate}
\end{enumerate}

%% For example, elementwise addition of two
%% 4-arrays-of-int could be expressed as an \texttt{Add} of 4-arrays or as
%% a \texttt{MapOp 4} over a scalar \texttt{Add}.

\end{document}

